"use strict";(self.webpackChunkrts_docs=self.webpackChunkrts_docs||[]).push([["4677"],{17348(e,n,s){s.r(n),s.d(n,{metadata:()=>a,default:()=>d,frontMatter:()=>t,contentTitle:()=>o,toc:()=>h,assets:()=>l});var a=JSON.parse('{"id":"hpc/tutorial_intro_hpc/environment_variables","title":"Environment Variables","description":"Questions","source":"@site/docs/hpc/13_tutorial_intro_hpc/05_environment_variables.mdx","sourceDirName":"hpc/13_tutorial_intro_hpc","slug":"/hpc/tutorial_intro_hpc/environment_variables","permalink":"/docs/hpc/tutorial_intro_hpc/environment_variables","draft":false,"unlisted":false,"editUrl":"https://github.com/NYU-RTS/rts-docs/blob/main/docs/hpc/13_tutorial_intro_hpc/05_environment_variables.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"hpcSidebar","previous":{"title":"Scheduler Fundamentals","permalink":"/docs/hpc/tutorial_intro_hpc/scheduler_fundamentals"},"next":{"title":"Accessing software via Modules","permalink":"/docs/hpc/tutorial_intro_hpc/modules"}}'),i=s(62615),r=s(30416);let t={},o="Environment Variables",l={},h=[{value:"Showing the Value of a Variable",id:"showing-the-value-of-a-variable",level:2},{value:"Creating and Changing Variables",id:"creating-and-changing-variables",level:2},{value:"Environment variables",id:"environment-variables-1",level:2},{value:"The <code>PATH</code> Environment Variable",id:"the-path-environment-variable",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"environment-variables",children:"Environment Variables"})}),"\n",(0,i.jsxs)(n.admonition,{title:"Overview",type:"info",children:[(0,i.jsx)(n.p,{children:"Questions"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"How are variables set and accessed in the Unix shell?"}),"\n",(0,i.jsx)(n.li,{children:"How can I use variables to change how a program runs?"}),"\n"]}),(0,i.jsx)(n.p,{children:"Objectives"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand how variables are implemented in the shell"}),"\n",(0,i.jsx)(n.li,{children:"Read the value of an existing variable"}),"\n",(0,i.jsx)(n.li,{children:"Create new variables and change their values"}),"\n",(0,i.jsx)(n.li,{children:"Change the behaviour of a program using an environment variable"}),"\n",(0,i.jsx)(n.li,{children:"Explain how the shell uses the PATH variable to search for executables"}),"\n"]})]}),"\n",(0,i.jsx)(n.admonition,{title:"Provenance",type:"info",children:(0,i.jsxs)(n.p,{children:["This episode has been remixed from the ",(0,i.jsx)(n.a,{href:"https://github.com/carpentries-incubator/shell-extras/blob/gh-pages/_episodes/08-environment-variables.md",children:"Shell Extras episode on Shell Variables"})," and the ",(0,i.jsx)(n.a,{href:"https://github.com/hpc-carpentry/hpc-shell/blob/gh-pages/_episodes/05-scripts.md",children:"HPC Shell episode on scripts"})]})}),"\n",(0,i.jsx)(n.p,{children:"The shell is just a program, and like other programs, it has variables. Those variables control its execution, so by changing their values you can change how the shell behaves (and with a little more effort how other programs behave)."}),"\n",(0,i.jsx)(n.p,{children:"Variables are a great way of saving information under a name you can access later. In programming languages like Python and R, variables can store pretty much anything you can think of. In the shell, they usually just store text. The best way to understand how they work is to see them in action."}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s start by running the command ",(0,i.jsx)(n.code,{children:"set"})," and looking at some of the variables in a typical shell session:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ set\nSHELL=/bin/bash\nWINDOWID=87\nSINGULARITY_CACHEDIR=/state/partition1/NYUNetID-singularity-cache\nCOLORTERM=truecolor\nHISTCONTROL=ignoredups\nHISTSIZE=1000\nHOSTNAME=log-3\nFPATH=/usr/share/zsh/5.5.1/functions:/usr/share/zsh/5.5.1/functions:/share/apps/lmod/8.4.9/lmod/lmod/init/ksh_funcs\nSSH_AUTH_SOCK=/tmp/ssh-XXXXb32gan/agent.3025643\n__LMOD_REF_COUNT_MODULEPATH=/share/apps/modulefiles:1\nVAST=/vast/NYUNetID\nLMOD_DIR=/share/apps/lmod/8.4.9/lmod/lmod/libexec\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, there are quite a few \u2014 in fact, four or five times more than what\u2019s shown here. And yes, using ",(0,i.jsx)(n.code,{children:"set"})," to ",(0,i.jsx)(n.em,{children:"show"})," things might seem a little strange, even for Unix, but if you don\u2019t give it any arguments, it might as well show you things you ",(0,i.jsx)(n.em,{children:"could"})," set."]}),"\n",(0,i.jsxs)(n.p,{children:["Every variable has a name. All shell variables\u2019 values are strings, even those (like ",(0,i.jsx)(n.code,{children:"UID"}),") that look like numbers. It\u2019s up to programs to convert these strings to other types when necessary. For example, if a program wanted to find out how many processors the computer had, it would convert the value of the ",(0,i.jsx)(n.code,{children:"NUMBER_OF_PROCESSORS"})," variable from a string to an integer."]}),"\n",(0,i.jsx)(n.h2,{id:"showing-the-value-of-a-variable",children:"Showing the Value of a Variable"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s show the value of the variable HOME:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ echo HOME\nHOME\n"})}),"\n",(0,i.jsx)(n.p,{children:"That just prints \u201CHOME\u201D, which isn\u2019t what we wanted (though it is what we actually asked for). Let\u2019s try this instead:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ echo $HOME\n/home/NetID\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The dollar sign tells the shell that we want the ",(0,i.jsx)(n.code,{children:"value"})," of the variable rather than its name. This works just like wildcards: the shell does the replacement ",(0,i.jsx)(n.em,{children:"before"})," running the program we\u2019ve asked for. Thanks to this expansion, what we actually run is ",(0,i.jsx)(n.code,{children:"echo /home/NetID"}),", which displays the right thing."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-and-changing-variables",children:"Creating and Changing Variables"}),"\n",(0,i.jsxs)(n.p,{children:["Creating a variable is easy \u2014 we just assign a value to a name using \u201C=\u201D (we just have to remember that the syntax requires that there are ",(0,i.jsx)(n.em,{children:"no"})," spaces around the ",(0,i.jsx)(n.code,{children:"="}),"!):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ SECRET_IDENTITY=Dracula\n$ echo $SECRET_IDENTITY\nDracula\n"})}),"\n",(0,i.jsx)(n.p,{children:"To change the value, just assign a new one:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ SECRET_IDENTITY=Camilla\n$ echo $SECRET_IDENTITY\nCamilla\n"})}),"\n",(0,i.jsx)(n.h2,{id:"environment-variables-1",children:"Environment variables"}),"\n",(0,i.jsxs)(n.p,{children:["When we ran the ",(0,i.jsx)(n.code,{children:"printenv"})," command we saw there were a lot of variables whose names were in upper case. That\u2019s because, by convention, variables that are also available to use by ",(0,i.jsx)(n.em,{children:"other"})," programs are given upper-case names. Such variables are called ",(0,i.jsx)(n.em,{children:"environment variables"})," as they are shell variables that are defined for the current shell and are inherited by any child shells or processes."]}),"\n",(0,i.jsxs)(n.p,{children:["To create an environment variable you need to ",(0,i.jsx)(n.code,{children:"export"})," a shell variable. For example, to make our ",(0,i.jsx)(n.code,{children:"SECRET_IDENTITY"})," available to other programs that we call from our shell we can do:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ SECRET_IDENTITY=Camilla\n$ export SECRET_IDENTITY\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also create and export the variable in a single step:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ export SECRET_IDENTITY=Camilla\n"})}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)("summary",{children:(0,i.jsxs)(n.admonition,{title:"Using environment variables to change program behaviour",type:"info",children:[(0,i.jsxs)(n.p,{children:["Set a shell variable ",(0,i.jsx)(n.code,{children:"TIME_STYLE"})," to have a value of ",(0,i.jsx)(n.code,{children:"iso"})," and check this value using the ",(0,i.jsx)(n.code,{children:"echo"})," command."]}),(0,i.jsxs)(n.p,{children:["Now, run the command ",(0,i.jsx)(n.code,{children:"ls"})," with the option ",(0,i.jsx)(n.code,{children:"-l"})," (which gives a long format)."]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"export"})," the variable and rerun the ",(0,i.jsx)(n.code,{children:"ls -l"})," command. Do you notice any difference? ",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:"[Click for Solution]"})]})]})}),(0,i.jsx)(n.admonition,{title:"Solution",type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"TIME_STYLE"})," variable is not ",(0,i.jsx)(n.em,{children:"seen"})," by ",(0,i.jsx)(n.code,{children:"ls"})," until is exported, at which point it is used by ",(0,i.jsx)(n.code,{children:"ls"})," to decide what date format to use when presenting the timestamp of files."]})})]}),"\n",(0,i.jsxs)(n.p,{children:["You can see the complete set of environment variables in your current shell session with the command ",(0,i.jsx)(n.code,{children:"env"})," (which returns a subset of what the command ",(0,i.jsx)(n.code,{children:"set"})," gave us). The complete set of environment variables is called your ",(0,i.jsx)(n.em,{children:"runtime environment"})," and can affect the behaviour of the programs you run."]}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)(n.admonition,{title:"Job environment variables",type:"info",children:(0,i.jsxs)(n.p,{children:["When Slurm runs a job, it sets a number of environment variables for the job. One of these will let us check what directory our job script was submitted from. The ",(0,i.jsx)(n.code,{children:"SLURM_SUBMIT_DIR"})," variable is set to the directory from which our job was submitted. Using the ",(0,i.jsx)(n.code,{children:"SLURM_SUBMIT_DIR"})," variable, modify your job so that it prints out the location from which the job was submitted. ",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.strong,{children:"[Click for Solution]"})]})})}),(0,i.jsx)(n.admonition,{title:"Solution",type:"tip",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'[NetID@log-1 ~]$ nano example-job.sh\n[NetID@log-1 ~]$ cat example-job.sh\n#!/bin/bash\n#SBATCH -t 00:00:30\n\necho -n "This script is running on "\nhostname\n\necho "This job was launched in the following directory:"\necho ${SLURM_SUBMIT_DIR}\n'})})})]}),"\n",(0,i.jsxs)(n.p,{children:["To remove a variable or environment variable you can use the ",(0,i.jsx)(n.code,{children:"unset"})," command, for example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ unset SECRET_IDENTITY\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"the-path-environment-variable",children:["The ",(0,i.jsx)(n.code,{children:"PATH"})," Environment Variable"]}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, some environment variables (like ",(0,i.jsx)(n.code,{children:"PATH"}),") store lists of values. In this case, the convention is to use a colon \u2018:\u2019 as a separator. If a program wants the individual elements of such a list, it\u2019s the program\u2019s responsibility to split the variable\u2019s string value into pieces."]}),"\n",(0,i.jsxs)(n.p,{children:["Let\u2019s have a closer look at that ",(0,i.jsx)(n.code,{children:"PATH"})," variable. Its value defines the shell\u2019s search path for executables, i.e., the list of directories that the shell looks in for runnable programs when you type in a program name without specifying what directory it is in."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, when we type a command like ",(0,i.jsx)(n.code,{children:"analyze"}),", the shell needs to decide whether to run ",(0,i.jsx)(n.code,{children:"./analyze"})," or ",(0,i.jsx)(n.code,{children:"/bin/analyze"}),". The rule it uses is simple: the shell checks each directory in the ",(0,i.jsx)(n.code,{children:"PATH"})," variable in turn, looking for a program with the requested name in that directory. As soon as it finds a match, it stops searching and runs the program."]}),"\n",(0,i.jsxs)(n.p,{children:["To show how this works, here are the components of ",(0,i.jsx)(n.code,{children:"PATH"})," listed one per line:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"/share/apps/singularity/bin\n/share/apps/local/bin\n/home/NetID/.local/bin\n/home/NetID/bin\n/share/apps/singularity/bin\n/share/apps/local/bin\n/usr/local/bin\n/usr/bin\n/usr/local/sbin\n/usr/sbin\n/usr/lpp/mmfs/bin\n/opt/slurm/bin\n"})}),"\n",(0,i.jsxs)(n.p,{children:["On our computer, there are actually three programs called ",(0,i.jsx)(n.code,{children:"analyze"})," in three different directories: ",(0,i.jsx)(n.code,{children:"/bin/analyze"}),", ",(0,i.jsx)(n.code,{children:"/usr/local/bin/analyze"}),", and ",(0,i.jsx)(n.code,{children:"/users/NetID/analyze"}),". Since the shell searches the directories in the order they\u2019re listed in ",(0,i.jsx)(n.code,{children:"PATH"}),", it finds ",(0,i.jsx)(n.code,{children:"/bin/analyze"})," first and runs that. Notice that it will never find the program ",(0,i.jsx)(n.code,{children:"/users/NetID/analyze"})," unless we type in the full path to the program, since the directory ",(0,i.jsx)(n.code,{children:"/users/NetID"})," isn\u2019t in ",(0,i.jsx)(n.code,{children:"PATH"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This means that I can have executables in lots of different places as long as I remember that I need to update my ",(0,i.jsx)(n.code,{children:"PATH"})," so that my shell can find them."]}),"\n",(0,i.jsxs)(n.p,{children:["What if I want to run two different versions of the same program? Since they share the same name, if I add them both to my PATH the first one found will always win. In the next episode we\u2019ll learn how to use helper tools to help us manage our runtime environment to make that possible without us needing to do a lot of bookkeeping on what the value of ",(0,i.jsx)(n.code,{children:"PATH"})," (and other important environment variables) is or should be."]}),"\n",(0,i.jsx)(n.admonition,{title:"Key Points",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Shell variables are by default treated as strings"}),"\n",(0,i.jsxs)(n.li,{children:["Variables are assigned using ",(0,i.jsx)(n.code,{children:"="})," and recalled using the variable\u2019s name prefixed by ",(0,i.jsx)(n.code,{children:"$"})]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"export"})," to make an variable available to other programs"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"PATH"})," variable defines the shell\u2019s search path"]}),"\n"]})})]})}function d(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},30416(e,n,s){s.d(n,{R:()=>t,x:()=>o});var a=s(59471);let i={},r=a.createContext(i);function t(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);